<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow-x: auto;
            margin-top: 1rem;
        }
    </style>
</head>

<body>
    <h1 class="main-title">JavaScript and Document Object Model</h1>

    <div class="section">
        <h3>
            <li>The Document Object Model (DOM)</li>
        </h3>

        <p>The Document Object Model (DOM) is a fundamental concept for web developers working with JavaScript (JS). It
            acts as a bridge between your JS code and the HTML structure of a webpage, allowing you to dynamically
            manipulate and interact with the content displayed on the screen. Imagine the DOM as a blueprint – a
            hierarchical tree representing the web page's structure. Let's delve into the world of DOM and explore how
            it empowers you to create interactive web experiences.</p>

        <ul>
            <h4>Understanding the DOM Structure:</h4>
            <li><span>A Tree-like Representation:</span> The DOM portrays a web page as a tree structure. The document
                itself is the root, with various HTML elements like &lt;div&gt;, &lt;p&gt;, or custom tags branching out
                as nodes. Text content within these elements forms the leaves of the tree.</li>
            <li><span>Nodes:</span> The Building Blocks: Each node in the DOM tree holds properties and methods that
                provide information and functionalities. You can access and modify elements, their attributes (think of
                them as characteristics, like an id or a class), and even their content using JS.</li>
            <li>
                <span>Common Node Types:</span> The DOM consists of various node types, each playing a specific role:
                <ul>
                    <li>Element Nodes: Represent the HTML building blocks you see on the page (e.g., &lt;div&gt;,
                        &lt;&gt;).</li>
                    <li>Text Nodes: Contain the actual text content displayed within elements.</li>
                    <li>Attribute Nodes: Store the attributes (or characteristics) associated with elements.</li>
                    <li>Comment Nodes: Hold comments embedded within the HTML code, typically for developer reference.
                    </li>
                </ul>
            </li>
            <h4>Interacting with the DOM using JavaScript:</h4>
            <li><span>Accessing Nodes:</span> JS provides powerful methods to target specific elements or groups of
                elements. You can use methods like document.getElementById() to find an element with a specific ID,
                document.querySelector() for more advanced element selection using CSS selectors, or
                document.getElementsByTagName() to retrieve all elements with a particular tag name.</li>
            <li><span>Modifying Nodes:</span> Once you have a reference to a node, you can manipulate it in various
                ways. Change the content of a paragraph using innerHTML or textContent, add or remove attributes, or
                even create new elements and insert them into the DOM structure. Imagine dynamically updating a product
                list or creating interactive animations – all through DOM manipulation! </li>
            <li><span>Event Handling:</span> Making Pages Interactive: The magic truly unfolds with events. The DOM
                allows you to attach event listeners to elements. These listeners watch for user interactions (clicks,
                key presses, form submissions, etc.) and trigger JS code execution when those events occur. This is how
                web pages become interactive! For instance, clicking a button might trigger a function that hides or
                displays a specific section of the page.</li>
        </ul>
    </div>

    <div class="section">
        <h3>
            <li>Element access</li>
        </h3>

        <p>Accessing elements is a fundamental skill for working with the Document Object Model (DOM) in JavaScript. It
            allows you to target specific parts of your HTML structure and interact with them using your JS code. Here's
            a breakdown of the common methods for element access:</p>

        <h4>1. Accessing by ID:</h4>
        <p>The document.getElementById() method is the most straightforward way to target an element with a unique id
            attribute in your HTML. The ID acts like an identifier, and the method returns a reference to the
            corresponding element if found.</p>
        <pre>
            <code>
                &lt;h1 id=&quot;main-heading&quot;&gt;This is the main heading&lt;/h1&gt;
            </code>
        </pre>
        <pre>
            <code>
                let headingElement = document.getElementById("main-heading");
                console.log(headingElement); // Outputs the reference to the h1 element
            </code>
        </pre>

        <h4>2. Accessing by Tag Name:</h4>
        <p>The document.getElementsByTagName() method retrieves a collection (an HTMLCollection object) of all elements
            with a specified tag name. This method is useful when you have multiple elements of the same type and want
            to loop through them or perform an action on all of them.</p>
        <pre>
            <code>
                &lt;p&gt;This is the first paragraph.&lt;/p&gt;
                &lt;p&gt;This is the second paragraph.&lt;/p&gt;
            </code>
        </pre>
        <pre>
            <code>
                let allParagraphs = document.getElementsByTagName("p");
                console.log(allParagraphs); // Outputs an HTMLCollection of all &lt;p&gt; elements
        
                for (let i = 0; i &lt; allParagraphs.length; i++) {
                    console.log(allParagraphs[i]); // Access each paragraph element
                }
            </code>
        </pre>

        <h4>3. Accessing by Class Name:</h4>
        <p>The document.getElementsByClassName() method returns an HTMLCollection of all elements with a specified class
            name. Similar to tag names, this is useful for working with multiple elements that share the same class.</p>
        <pre>
            <code>
                &lt;div class=&quot;special-box&quot;&gt;This is a special box.&lt;/div&gt;
                &lt;div class=&quot;another-box&quot;&gt;This is another box.&lt;/div&gt;
            </code>
        </pre>
        <pre>
            <code>
                let specialBoxes = document.getElementsByClassName("special-box");
                console.log(specialBoxes); // Outputs an HTMLCollection of all elements with class "special-box"
            </code>
        </pre>

        <h4>4. Accessing with Query Selectors:</h4>
        <p>JavaScript offers a more powerful approach using document.querySelector() and document.querySelectorAll().
            These methods leverage CSS selectors, similar to what you use in stylesheets, to target elements very
            precisely.</p>

        <ul>
            <li>document.querySelector() returns the first element that matches the CSS selector.</li>
            <li>document.querySelectorAll() returns a NodeList of all elements that match the selector.</li>
        </ul>
        <pre>
            <code>
                &lt;ul id=&quot;items-list&quot;&gt;
                    &lt;li class=&quot;item&quot;&gt;Item 1&lt;/li&gt;
                    &lt;li class=&quot;item&quot;&gt;Item 2&lt;/li&gt;
                &lt;/ul&gt;
            </code>
        </pre>
        <pre>
            <code>
                let firstItem = document.querySelector(&quot;#items-list li.item&quot;); // Targets the first list item with class &quot;item&quot;
                console.log(firstItem);
        
                let allItems = document.querySelectorAll(&quot;#items-list li.item&quot;); // Selects all list items with class &quot;item&quot;
                console.log(allItems); // Outputs a NodeList
            </code>
        </pre>

    </div>

    <div class="section">
        <h3>
            <li>Events and event handling</li>
        </h3>

        <p>In the world of web development, events are user interactions or occurrences within a web page that trigger
            the execution of JavaScript code. Event handling is the mechanism that allows you to listen for these events
            and define how your web page responds to them. This creates a dynamic and interactive user experience.</p>

        <h4>Here's a breakdown of events and event handling in JavaScript:</h4>

        <h4>Types of Events:</h4>
        <p>There are numerous events that can occur on a web page, including:</p>
        <ul>
            <li><span>Mouse Events:</span> Clicks, double clicks, hovering over elements, pressing buttons, scrolling,
                etc.</li>
            <li><span>Keyboard Events:</span> Key presses, holding down keys, releasing keys, etc.</li>
            <li><span>Form Events:</span> Submitting forms, changing form element values, etc.</li>
            <li><span>DOM Events:</span> Elements being loaded, inserted, removed, etc.</li>
            <li><span>Window Events:</span> The browser window being loaded, resized, scrolled, etc.</li>
        </ul>

        <h4>Event Handlers: The Listeners</h4>
        <p>Event handlers are JavaScript functions that are associated with specific events on HTML elements. When the
            event occurs, the corresponding event handler function is executed. Here's the basic structure:

        </p>
        <pre>
            <code>
                &lt;button id=&quot;myButton&quot;&gt;Click me!&lt;/button&gt;
            </code>
        </pre>
        <pre>
            <code>
                let buttonElement = document.getElementById("myButton");
        
                function handleClick() {
                  alert("The button was clicked!");
                }
        
                buttonElement.addEventListener("click", handleClick);
            </code>
        </pre>

        <ul>
            <h5>In this example:</h5>
            <li>We target the button element using document.getElementById().</li>
            <li>We define a function handleClick() that displays an alert message.</li>
            <li>We use the addEventListener() method to attach the handleClick function to the button element's "click"
                event.</li>

            <h4>Common Event Handling Methods:</h4>

            <li><span>addEventListener(event, handler):</span> Adds an event listener to an element.</li>
            <li><span>removeEventListener(event, handler)</span> Removes an event listener from an element.</li>
            <li><span>dispatchEvent(event):</span> Triggers a specific event on an element (useful for simulating
                events).</li>

            <h4>Benefits of Event Handling:</h4>
            <li><span>Dynamic User Interactions:</span> Event handling allows you to create web pages that react to user
                input, making them more engaging and user-friendly.</li>
            <li><span>Form Validation:</span> You can use event handlers to validate user input in forms before
                submitting them, preventing errors and improving data integrity.</li>
            <li><span>Animations and Effects:</span> Event handling is essential for creating interactive animations and
                visual effects that respond to user actions.</li>
        </ul>

        <p>In conclusion, mastering events and event handling is a fundamental skill for building interactive web
            applications with JavaScript. By understanding different event types, attaching event listeners, and
            utilizing the event object, you can create dynamic and responsive web pages that come alive with user
            interaction.</p>
    </div>

    <div class="section">
        <h3>
            <li>Handling events - Body elements, button elements, textbox, password</li>
        </h3>

        <h4>Body Element:</h4>
        <p>While not as common as other elements, you can listen for events on the &lt;body&gt; element to capture
            interactions that happen anywhere within the document body (the visible content area). Here's an example of
            handling a click event on the body:</p>
        <pre>
            <code>
                &lt;body&gt;
                    &lt;script&gt;
                        document.body.addEventListener("click", function() {
                            console.log("You clicked anywhere on the page!");
                        });
                    &lt;/script&gt;
                &lt;/body&gt;
            </code>
        </pre>

        <h4>Button Element:</h4>
        <p>Buttons are essential for user interaction. Here are common events you might handle on buttons:</p>
        <ul>
            <li>Click Event: This is the most common event for buttons. You can define a function to execute when the
                button is clicked</li>
            <pre>
                <code>
                    &lt;script&gt;
                        let button = document.getElementById("myButton");
            
                        button.addEventListener("click", function() {
                            alert("The button was clicked!");
                        });
                    &lt;/script&gt;
                </code>
            </pre>

            <li>Mouse Events: You can also listen for events like mouseover (hovering over the button) or mouseout
                (leaving the button) to create interactive effects.</li>
            <pre>
                <code>
                    &lt;script&gt;
                        let button = document.getElementById("myButton");
            
                        button.addEventListener("mouseover", function() {
                            button.style.backgroundColor = "lightblue"; // Change button color on hover
                        });
            
                        button.addEventListener("mouseout", function() {
                            button.style.backgroundColor = ""; // Reset button color onmouseout
                        });
                    &lt;/script&gt;
                </code>
            </pre>
        </ul>

        <h4>Textbox and Password Elements:</h4>
        <p>Textboxes and password elements allow users to enter text data. Here are key events to handle:</p>
        <ul>
            <li>Change Event: This event fires whenever the content of the textbox or password field changes. It's
                useful for real-time validation or updating other parts of the page dynamically.</li>
            <pre>
                <code>
                    &lt;script&gt;
                        let usernameInput = document.getElementById("usernameInput");
            
                        usernameInput.addEventListener("change", function() {
                            let enteredUsername = usernameInput.value;
                            console.log("Username entered:", enteredUsername);
                        });
                    &lt;/script&gt;
                </code>
            </pre>

            <li>Keypress Event: This event fires every time a key is pressed while the textbox or password field is
                focused. You can use it to restrict allowed characters or perform actions based on specific keys
                pressed.</li>

            <pre>
                <code>
                    &lt;script&gt;
                        let passwordInput = document.getElementById("passwordInput");
            
                        passwordInput.addEventListener("keypress", function(event) {
                            let keyPressed = event.key;
                            if (keyPressed.length &gt; 1) { // Prevent special characters (assuming only letters and numbers are allowed)
                                event.preventDefault(); // Prevent invalid character from being entered
                            }
                        });
                    &lt;/script&gt;
                </code>
            </pre>
        </ul>
    </div>

    <div class="section">
        <h3>
            <li>DOM 2 Event Model</li>
        </h3>

        <P>The DOM Level 2 Event Model (DOM 2) introduced a standardized way to handle events in web pages. It aimed to
            address limitations in earlier DOM specifications and provide a more consistent experience across different
            browsers. Here's a breakdown of its key features:</P>

        <h4>Core principles:</h4>
        <ul>
            <li><span>Generic event system:</span> DOM 2 defines a general event handling mechanism that allows
                attaching event listeners to any element in the Document Object Model (DOM) tree.</li>
            <li>
                <span> Event flow:</span> It establishes a well-defined path for events to propagate through the DOM
                tree. This flow typically involves three phases:

                <ul>
                    <li>Capturing phase (optional): Events can optionally trigger handlers on elements ancestral to the
                        target element (from the root down to the target).</li>
                    <li>Target phase: The event reaches the target element where the event originated, and its
                        registered handlers are executed.</li>
                    <li>Bubbling phase: The event propagates back up the DOM tree, triggering handlers on elements that
                        are parents of the target element (from target to the root).
                    </li>
                </ul>
            </li>
            <li><span>Event interfaces:</span> DOM 2 defines a base Event interface that provides details about the
                event, such as its type (e.g., 'click'), target element, and timestamps. Specific event types like
                MouseEvent or KeyboardEvent inherit from this base interface and offer additional properties relevant to
                their type.</li>


            <h4>Benefits:</h4>
            <li><span>Consistency:</span> DOM 2 promotes consistent event handling across browsers, making web
                development more predictable.</li>
            <li><span>Flexibility:</span> It allows attaching multiple event listeners to the same element, enabling
                more complex interactions.</li>
            <li><span>Event object:</span> The Event object provides valuable information about the event, allowing
                developers to react accordingly.
            </li>
        </ul>
    </div>

    <div class="section">
        <h3>
            <li>DOM Tree Traversal and Modification</li>
        </h3>

        <p>DOM Tree Traversal and Modification are fundamental techniques for working with web pages in JavaScript. Let's break them down:</p>

        <h4>DOM Tree Traversal:</h4>

        <p>Imagine the structure of an HTML document as an upside-down tree. Each element in the HTML forms a node in this tree, with the &lt;html&gt; element being the root. Traversal refers to navigating through this tree to access and interact with specific elements.</p>

        <h4>Here are common methods for DOM Tree Traversal:</h4>
        <ul>
            <li><span>getElementById(id):</span> Retrieves an element by its unique identifier.</li>
            <li><span>getElementsByTagName(tagName):</span> Returns a collection of elements with a specified tag name (e.g., all &lt;h1&gt; elements).</li>
            <li><span>getElementsByClassName(className):</span> Returns a collection of elements with a specific CSS class.</li>
            <li><span>querySelector(selector):</span> Uses CSS selectors (like you would in stylesheets) to target a single element.</li>
            <li><span>querySelectorAll(selector):</span> Similar to querySelector, but returns a collection of elements matching the selector.</li>

            <p>Once you have a reference to an element, you can use its properties to navigate the tree:</p>

            <li><span>parentNode:</span> Points to the parent element of the current element.</li>
            <li><span>childNodes:</span> Returns a collection of child nodes of the current element (including text nodes and comments).</li>
            <li><span>firstChild:</span> References the first child node.</li>
            <li><span>lastChild:</span> References the last child node.</li>
            <li><span>nextSibling:</span> Points to the next sibling element after the current one</li>
            <li><span>previousSibling:</span> Points to the previous sibling element before the current one.</li>
        </ul>

        <h4>DOM Tree Modification:</h4>
        <p>After traversing to a specific element, you can modify its content, attributes, or style using JavaScript methods:</p>

        <ul>
            <li><span>innerHTML:</span> Sets or retrieves the HTML content within the element.</li>
            <li><span>textContent:</span> Sets or retrieves the text content of the element (excluding HTML tags).</li>
            <li><span>setAttribute(attributeName, value):</span> Sets the value of a specific attribute on the element.</li>
            <li><span>getAttribute(attributeName):</span> Retrieves the value of a specific attribute.</li>
            <li><span>classList:</span> Allows adding, removing, or toggling CSS classes on the element.</li>
            <li><span>style:</span> Provides access to the element's inline styles, allowing modification of properties like color, font-size, etc.</li>
        </ul>
        <p>By combining DOM Tree Traversal and Modification techniques, you can dynamically change the content and appearance of your web page based on user interactions or other events.</p>
    </div>

    <div class="section">
        <h3>
            <li>DOM Collecction</li>
        </h3>

        <p>In the context of the DOM (Document Object Model), collections group related elements together. These collections are live, meaning changes made to the underlying HTML document are reflected in the collection. Here's a closer look at DOM Collections:</p>

        <ul>
            <h4>Types of DOM Collections:</h4>
            <li>HTMLCollection: A collection-like object that contains HTML elements in the order they appear in the document. It's primarily used with methods like document.getElementsByTagName() or document.getElementsByClassName(). Keep in mind that although it resembles an array, it's not a true array and lacks some array methods.</li>
            <li>NodeList: Similar to HTMLCollection, it contains an ordered list of nodes (including elements, comments, and text nodes) extracted from a document using methods like document.querySelectorAll() or the childNodes property of an element. It also has limitations similar to HTMLCollection.</li>
            <li>FormElement Collection: Specifically designed to access all &lt;input&gt; elements (text fields, checkboxes, radio buttons, etc.) within a <form> element. You can access it using the elements property of the form object.</li>

                <h4>Key Points:</h4>
            <li>Read-only: DOM collections themselves cannot be directly modified. You can't add, remove, or sort elements within the collection.</li>
            <li>Iteration: You can iterate over the elements in a collection using a loop (like for...of) or array methods like forEach().</li>

            <li>Accessing elements: Use the index (starting from 0) to access specific elements within the collection.</li>
            <li>Here's an example of using a NodeList to change the background color of all &lt;h1&gt; elements:</li>

            <pre>
                <code>
                    const headings = document.querySelectorAll('h1');
            
                    for (const heading of headings) {
                        heading.style.backgroundColor = 'lightblue';
                    }
                </code>
            </pre>

            <h4>Additional Considerations:</h4>
            <li>Since DOM collections are live, it's generally recommended to convert them to a true array if you need to use array methods extensively for performance reasons. You can use Array.from() to achieve this.</li>
            <li>Be cautious when modifying the DOM while iterating over a collection. Changes to the DOM structure might affect the iteration process.</li>
        </ul>
    </div>

    <div class="section">
        <h3>
            <li>Dynamic Styles</li>
        </h3>

        <p>Dynamic styles refer to the ability to control the visual appearance of HTML elements in a web page using JavaScript. This allows you to create more interactive and responsive user experiences. Here are the two main approaches for achieving dynamic styles:</p>

        <ul>
            <h4>1.Manipulating Inline Styles:</h4>
            <li>This approach involves directly modifying the style property of an element in the DOM. The style property is an object that represents all the inline CSS styles applied to that element.</li>

            <li>Here's how to access and modify inline styles:</li>
            <pre>
                <code>
                    const element = document.getElementById('myElement');
                    element.style.color = 'red'; // Change the text color to red
                    element.style.fontSize = '20px'; // Set the font size to 20px
                </code>
            </pre>
            <li>While this approach is simple, it can become cumbersome for complex styling changes and lead to less maintainable code.</li>   
            
            <h4>2.Adding and Removing CSS Classes:</h4>

            <li>This approach leverages pre-defined CSS classes in a stylesheet to control element styles. You can dynamically add or remove these classes from elements using JavaScript.</li>
            <li>Here's how to add and remove classes:</li>
            <pre>
                <code>
                    const element = document.getElementById('myElement');
                    element.classList.add('active'); // Add the 'active' class
                    element.classList.remove('hidden'); // Remove the 'hidden' class
                </code>
            </pre>
            <li>This approach promotes separation of concerns by keeping styles defined in CSS and logic for applying them in JavaScript. It also allows for easier reuse and maintenance of styles.</li>
            
            <h4>Choosing the Right Approach:</h4>

            <li>Use inline styles for minor, one-time style changes or when you need to dynamically generate styles based on calculations.</li>
            <li>Use CSS classes for most styling scenarios, especially when you have reusable styles or complex styling logic.</li>

            <h4>Additional Techniques:</h4>
            <li>CSSOM (CSS Object Model): This advanced approach allows you to create and insert new CSS rules directly into the stylesheet at runtime. However, it's less commonly used due to potential browser compatibility issues.</li>
        </ul>
    </div>
</body>

</html>